package com.laboratory.sudoku;

import java.util.ArrayList;
import java.util.Random;

/**
 * Created by Li on 2016/11/16.
 */
public class PuzzleController {
    // class to store position of cell
    class CellPosition{
        public CellPosition(){
            positionX = 0;
            positionY = 0;
        }

        public CellPosition(int x, int y){
            positionX = x;
            positionY = y;
        }

        public void setValue(int x, int y) {
            positionX = x;
            positionY = y;
        }

        public int getPositionX() {
            return positionX;
        }

        public void setPositionX(int positionX) {
            this.positionX = positionX;
        }

        public int getPositionY() {
            return positionY;
        }

        public void setPositionY(int positionY) {
            this.positionY = positionY;
        }

        private int positionX;
        private int positionY;

    }

    // data class to store a 9x9 sudoku
    class SudokuData{
        private int[][] puzzleResolution; // sudoku puzzle, generated by generator
        private int[][] knownValues; // values shown to user at start
        private int[][] userInput;

        public SudokuData(){
            puzzleResolution = new int[9][9];
            knownValues = new int[9][9];
            userInput = new int[9][9];
        }

        /**
         * Methods to read value
         * */
        public int getPuzzleResolutionValue(int RowNum, int ColumnNum){
            if ((RowNum > 8) || (RowNum < 0))
                return 0;
            if ((ColumnNum > 8) || (ColumnNum < 0))
                return 0;

            int value = puzzleResolution[RowNum][ColumnNum];
            return value;
        }

        public int getDefaultValue(int RowNum, int ColumnNum){
            if ((RowNum > 8) || (RowNum < 0))
                return 0;
            if ((ColumnNum > 8) || (ColumnNum < 0))
                return 0;

            int value = knownValues[RowNum][ColumnNum];
            return value;
        }

        public int getUserInputValue(int RowNum, int ColumnNum){
            if ((RowNum > 8) || (RowNum < 0))
                return 0;
            if ((ColumnNum > 8) || (ColumnNum < 0))
                return 0;

            int value = userInput[RowNum][ColumnNum];
            return value;
        }

        /**
         * Methods to set value
         * */
        public void setPuzzleResolutionValue(int RowNum, int ColumnNum, int value){
            if ((RowNum > 8) || (RowNum < 0))
                return;
            if ((ColumnNum > 8) || (ColumnNum < 0))
                return;

            puzzleResolution[RowNum][ColumnNum] = value;
        }

        public void setDefaultValue(int RowNum, int ColumnNum, int value){
            if ((RowNum > 8) || (RowNum < 0))
                return;
            if ((ColumnNum > 8) || (ColumnNum < 0))
                return;

            knownValues[RowNum][ColumnNum] = value;
        }

        public void setUserInputValue(int RowNum, int ColumnNum, int value){
            if ((RowNum > 8) || (RowNum < 0))
                return;
            if ((ColumnNum > 8) || (ColumnNum < 0))
                return;

            userInput[RowNum][ColumnNum] = value;
        }

        public boolean isResolutionCorrect(){
            for (int rowCounter = 0; rowCounter < 9; rowCounter++){
                for (int ColumnCounter = 0; ColumnCounter < 9; ColumnCounter++){
                    // for all non-default value, compare them with original puzzle
                    if (knownValues[rowCounter][ColumnCounter] != puzzleResolution[rowCounter][ColumnCounter]){
                        if (userInput[rowCounter][ColumnCounter] != puzzleResolution[rowCounter][ColumnCounter]){
                            return false;
                        }
                    }
                }
            }
            return true;
        }
    }

    // game related operations
    class PuzzlePlayer{
        private int hintToUse;
        private int maxHintToUse;

        PuzzlePlayer(){
            hintToUse = 0;
            maxHintToUse = 5;
        }

        public boolean isResolutionCorrect(){
            return puzzleData.isResolutionCorrect();
        }

        public void userFillValue(int RowNum, int ColumnNum, int value){
            puzzleData.setUserInputValue(RowNum, ColumnNum, value);

            //userInput[RowNum][ColumnNum] = value;
        }

        public void userEraseValue(int RowNum, int ColumnNum){
            puzzleData.setUserInputValue(RowNum, ColumnNum, 0);

            //userInput[RowNum][ColumnNum] = 0;
        }

        // reset m_UserResolution
        public void resetAllUserInput(){
            for (int RowNum = 0; RowNum < 9; RowNum ++){
                for (int ColumnNum = 0; ColumnNum < 9; ColumnNum ++){
                    puzzleData.setUserInputValue(RowNum, ColumnNum, 0);
                    //userInput[RowNum][ColumnNum] = 0;
                }
            }
        }

        // return if a cell of puzzle is already shown to user at start
        public boolean isDefault(int RowNum, int ColumnNum){

            //if (knownValues[RowNum][ColumnNum] != 0){
            if (puzzleData.getDefaultValue(RowNum, ColumnNum) != 0){
                return true;
            }

            return false;
        }

        // test if user input value at cell(x, y) is valid
        public boolean validateValueAtCell(int positionX, int positionY) {
            if ((positionX > 8) || (positionX < 0))
                return false;
            if ((positionY > 8) || (positionY < 0))
                return false;

            // m_UserResolution[positionX][positionY]
            // no same value at the same column
            for (int m = 0; m < 9; m++) {
                // no same value in user input value
                //if (m != positionX && userInput[m][positionY] == userInput[positionX][positionY]) {
                //    return false;
                //}
                // no same value in default value
                //if (m != positionX && knownValues[m][positionY] == userInput[positionX][positionY]) {
                //    return false;
                //}
                if (m != positionX && puzzleData.getUserInputValue(m, positionY) == puzzleData.getUserInputValue(positionX, positionY)) {
                    return false;
                }
                // no same value in default value
                if (m != positionX && puzzleData.getDefaultValue(m, positionY) == puzzleData.getUserInputValue(positionX, positionY)) {
                    return false;
                }
            }

            // no same value in the same row
            for (int n = 0; n < 9; n++) {
                // no same value in user input value
                //if (n != positionY && userInput[positionX][n] == userInput[positionX][positionY]) {
                //    return false;
                //}
                // no same value in default value
                //if (n != positionX && knownValues[positionX][n] == userInput[positionX][positionY]) {
                //    return false;
                //}
                if (n != positionY && puzzleData.getUserInputValue(positionX, n) == puzzleData.getUserInputValue(positionX, positionY)) {
                    return false;
                }
                // no same value in default value
                if (n != positionX && puzzleData.getDefaultValue(positionX, n) == puzzleData.getUserInputValue(positionX, positionY)) {
                    return false;
                }
            }

            // no same value in 3x3 area
            for (int p = positionX / 3 * 3, m = 0; m < 3; m++) {
                for (int q = positionY / 3 * 3, n = 0; n < 3; n++) {
                    // no same value in user input value
                    //if ((p + m != positionX || q + n != positionY)
                    //        && (userInput[p + m][q + n] == userInput[positionX][positionY])) {
                    //    return false;
                    //}
                    if ((p + m != positionX || q + n != positionY)
                            && (puzzleData.getUserInputValue(p + m, q + n) == puzzleData.getUserInputValue(positionX, positionY))) {
                        return false;
                    }

                    // no same value in default value
                    //if ((p + m != positionX || q + n != positionY)
                    //        && (knownValues[p + m][q + n] == userInput[positionX][positionY])) {
                    //    return false;
                    //}
                    if ((p + m != positionX || q + n != positionY)
                            && (puzzleData.getDefaultValue(p + m, q + n) == puzzleData.getUserInputValue(positionX, positionY))) {
                        return false;
                    }
                }
            }
            return true;
        }

        public int getPuzzleResolutionValue(int RowNum, int ColumnNum){
            if ((RowNum > 8) || (RowNum < 0))
                return 0;
            if ((ColumnNum > 8) || (ColumnNum < 0))
                return 0;

            int value = puzzleData.getPuzzleResolutionValue(RowNum, ColumnNum);
            return value;
        }

        public int getDefaultValue(int RowNum, int ColumnNum){
            if ((RowNum > 8) || (RowNum < 0))
                return 0;
            if ((ColumnNum > 8) || (ColumnNum < 0))
                return 0;

            int value = puzzleData.getDefaultValue(RowNum, ColumnNum);
            return value;
        }

        public int getUserInputValue(int RowNum, int ColumnNum){
            if ((RowNum > 8) || (RowNum < 0))
                return 0;
            if ((ColumnNum > 8) || (ColumnNum < 0))
                return 0;

            int value = puzzleData.getUserInputValue(RowNum, ColumnNum);
            return value;
        }

        public void setPuzzleResolutionValue(int RowNum, int ColumnNum, int value){
            if ((RowNum > 8) || (RowNum < 0))
                return;
            if ((ColumnNum > 8) || (ColumnNum < 0))
                return;

            if ((value > 9) || (value <= 0))
                return;

            puzzleData.setPuzzleResolutionValue(RowNum, ColumnNum, value);

        }

        public void setDefaultValue(int RowNum, int ColumnNum, int value){
            if ((RowNum > 8) || (RowNum < 0))
                return;
            if ((ColumnNum > 8) || (ColumnNum < 0))
                return;

            if ((value > 9) || (value <= 0))
                return;

            puzzleData.setDefaultValue(RowNum, ColumnNum, value);

        }

        public void setUserInputValue(int RowNum, int ColumnNum, int value){
            if ((RowNum > 8) || (RowNum < 0))
                return;
            if ((ColumnNum > 8) || (ColumnNum < 0))
                return;

            if ((value > 9) || (value <= 0))
                return;

            puzzleData.setUserInputValue(RowNum, ColumnNum, value);

        }

        public void getAllPuzzleResolution(ArrayList<String> data){

            for (int row = 0; row<9; row ++){
                for (int column = 0; column<9; column ++){
                    data.add( ((Integer)puzzleData.getPuzzleResolutionValue(row, column)).toString() );
                }
            }

        }

        public void getAllDefaultData(ArrayList<String> data){

            for (int row = 0; row<9; row ++){
                for (int column = 0; column<9; column ++){
                    data.add( ((Integer)puzzleData.getDefaultValue(row, column)).toString() );
                }
            }

        }

        public void getAllUserInput(ArrayList<String> data){

            for (int row = 0; row<9; row ++){
                for (int column = 0; column<9; column ++){
                    data.add( ((Integer)puzzleData.getUserInputValue(row, column)).toString() );
                }
            }

        }

        public void getHintData(ArrayList<String> data){
            data.add( ((Integer)getNumOfHint()).toString() );
        }

        public int getMaxHint(){
            return maxHintToUse;
        }

        // give hint at a given position
        // done by pass value from puzzleResolution to default
        public void GiveHintAtPosition(int row, int column){
            if (hintToUse > 0){
                puzzleData.setDefaultValue(row, column, puzzleData.getPuzzleResolutionValue(row, column));
                puzzleData.setUserInputValue(row, column, 0); // if user has already input value in this cell, reset it
                hintToUse --;
            }
        }

        public void setHintToUse(int number){
            if (number>0){
                hintToUse = number;
            }
        }

        public int getNumOfHint(){
            return hintToUse;
        }
    }

    class PuzzleGenerator{

        private int m_Level; // 1 - easy, 2 - normal, 3 - hard, 4 - very hard
        private int minFilled, minKnown; // minFilled - number of cells shown to user at start
                                 // minKnown - number of values known to user at start (for example, four '1' are shown to user at easy level)
        private Random ran = new Random(); //  random number generator

        /**
         * public methods
         * */
        public PuzzleGenerator(){
            setPuzzleLevel(2);
        }

        public PuzzleGenerator(int level){
            setPuzzleLevel(level);
        }

        public void setPuzzleLevel(int level){
            if ((level<=0)||(level>3)){
                this.m_Level = 2; // default level 2;
            }else{
                this.m_Level = level;
            }

            // decide m_minFilled and m_minKnow according to level
            switch (m_Level){
                case 1:
                    int ranNum = ran.nextInt(10);
                    if(ranNum > 4) {
                        minKnown = 5;
                    } else {
                        minKnown = 4;
                    }
                    minFilled = 45 + ranNum;
                    break;

                case 2:
                    minFilled = 31 + ran.nextInt(10);
                    minKnown = 3;
                    break;

                case 3:
                    minFilled = 21 + ran.nextInt(10);
                    minKnown = 2;
                    break;

                //case 4:
                //    minFilled = 17 + ran.nextInt(10);
                //    minKnown = 0;
                //    break;

                default: // default level 2
                    minFilled = 31 + ran.nextInt(10);
                    minKnown = 3;
                    break;
            }
        }

        public int getPuzzleLevel(){
            return m_Level;
        }

        public void generateSudokuPuzzle(){

            // generate sudoku according to m_minFilled and m_minKnow
            generateSudoku(minFilled, minKnown);

            //Log.d("PuzzleController", "sudoku generated");
        }

        /**
         * private methods
         * */
        // generate sudoku with 'digging-hole' method
        protected void generateSudoku(int minFilled, int minKnown){

            int startX = ran.nextInt(9), startY = ran.nextInt(9);
            int originStartX = startX, originStartY = startY;
            int filledCount = 81;

            int[][] temppuzzle = new int[9][9];

            // generate known cells
            generateKnownSudoku(11, temppuzzle);

            if (isSudokuSolvable(temppuzzle) == true){

                // store value in puzzleResolution
                // also store value in knownValues, later some value will be removed from it
                //for (int i = 0; i < 9; i++) {
                //    System.arraycopy(temppuzzle[i], 0, puzzleResolution[i], 0, 9);
                //    System.arraycopy(temppuzzle[i], 0, knownValues[i], 0, 9);
                //}
                for (int row = 0; row < 9; row ++){
                    for (int column = 0; column < 9; column ++){
                        puzzleData.setPuzzleResolutionValue(row, column, temppuzzle[row][column]);
                        puzzleData.setDefaultValue(row, column, temppuzzle[row][column]);
                    }
                }

                equalChange(temppuzzle);

                int[] nextHolePosition = new int[2]; // position of the next hole
                do {
                    int temMinKnow = getMinknown(temppuzzle, startX, startY);
                    if (isOnlyAnswer(temppuzzle, startX, startY) && temMinKnow >= minKnown) {
                        temppuzzle[startX][startY] = 0;
                        //knownValues[startX][startY] = 0;
                        puzzleData.setDefaultValue(startX, startY, 0);
                        filledCount--;
                    }
                    nextHole(startX, startY, nextHolePosition);
                    startX = nextHolePosition[0];
                    startY = nextHolePosition[1];
                    while(temppuzzle[startX][startY] == 0 && (originStartX != startX || originStartY != startY)) {
                        nextHole(startX, startY, nextHolePosition);
                        startX = nextHolePosition[0];
                        startY = nextHolePosition[1];
                    }
                    if((m_Level == 1) || (m_Level == 2)) {
                        while(startX == originStartX && startY == originStartY) {
                            nextHole(startX, startY, nextHolePosition);
                            startX = nextHolePosition[0];
                            startY = nextHolePosition[1];
                        }
                    }
                } while (filledCount > minFilled && (originStartX != startX || originStartY != startY));

            }else{
                generateSudoku(minFilled, minKnown);
            }
        }

        // generate values shown to user at start
        protected void generateKnownSudoku(int numOfCell, int[][] puzzle){

            // generate positions for known cells
            CellPosition[] knownPoints = new CellPosition[numOfCell];
            for (int i = 0; i < numOfCell; i++) {

                knownPoints[i] = new CellPosition(ran.nextInt(9), ran.nextInt(9));

                for (int k = 0; k < i; k++) {
                    if ((knownPoints[k].getPositionX() == knownPoints[i].getPositionX())
                            &&(knownPoints[k].getPositionY() ==knownPoints[i].getPositionY())) {
                        i--;
                        break;
                    }
                }
            }

            // for each position, find a proper value
            int num; // value to be filled in known position
            CellPosition position = new CellPosition();
            for (int i = 0; i < numOfCell; i++) {
                num = 1 + ran.nextInt(9);
                position.positionX = knownPoints[i].positionX;
                position.positionY = knownPoints[i].positionY;

                puzzle[position.positionX][position.positionY] = num;
                if (!validateValueAtCell(puzzle, position.positionX, position.positionY)) {
                    i--;
                }
            }
        }

        // test if the whole puzzle is valid
        public boolean isPuzzleValid(int[][] data) {
            for (int i = 0; i < 9; i++) {
                for (int j = 0; j < 9; j++) {
                    if (data[i][j] != 0 && !validateValueAtCell(data, i, j)) {
                        return false;
                    }
                }
            }
            return true;
        }

        // test if value at cell(x, y) is valid for puzzle
        protected boolean validateValueAtCell(int[][] puzzle, int positionX, int positionY) {
            if ((positionX > 8) || (positionX < 0))
                return false;
            if ((positionY > 8) || (positionY < 0))
                return false;

            // no same value at the same column
            for (int m = 0; m < 9; m++) {
                if (m != positionX && puzzle[m][positionY] == puzzle[positionX][positionY]) {
                    return false;
                }
            }

            // no same value in the same row
            for (int n = 0; n < 9; n++) {
                if (n != positionY && puzzle[positionX][n] == puzzle[positionX][positionY]) {
                    return false;
                }
            }

            // no same value in 3x3 area
            for (int p = positionX / 3 * 3, m = 0; m < 3; m++) {
                for (int q = positionY / 3 * 3, n = 0; n < 3; n++) {
                    if ((p + m != positionX || q + n != positionY)
                            && (puzzle[p + m][q + n] == puzzle[positionX][positionY])) {
                        return false;
                    }
                }
            }
            return true;
        }

        //
        protected int getMinknown(int[][] puzzle, int positionX, int positionY) {
            int temp = puzzle[positionX][positionY];
            int minKnow = 9;
            int tempKnow = 9;
            puzzle[positionX][positionY] = 0;

            for (int i = 0; i < 9; i++) {
                for (int j = 0; j < 9; j++) {
                    if (puzzle[i][j] == 0) {
                        tempKnow--;
                        if (tempKnow < minKnow) {
                            minKnow = tempKnow;
                        }
                    }
                }
                tempKnow = 9;
            }

            tempKnow = 9;
            for (int j = 0; j < 9; j++) {
                for (int i = 0; i < 9; i++) {
                    if (puzzle[i][j] == 0) {
                        tempKnow--;
                        if (tempKnow < minKnow) {
                            minKnow = tempKnow;
                        }
                    }
                }
                tempKnow = 9;
            }
            puzzle[positionX][positionY] = temp;

            return minKnow;
        }

        // check if the only resolution exists after digging hole at (x, y)
        protected boolean isOnlyAnswer(int[][] puzzle, int positionX, int positionY) {
            int k = puzzle[positionX][positionY];
            for (int num = 1; num < 10; num++) {
                puzzle[positionX][positionY] = num;
                if ((num != k) && (isSudokuSolvable(puzzle) == true)) {
                    puzzle[positionX][positionY] = k;
                    return false;
                }
            }
            puzzle[positionX][positionY] = k;
            return true;
        }

        // test if sudoku is solvable by solving it
        protected boolean isSudokuSolvable(int[][] puzzle){

            // save all the blank cells in blankList
            int blankCount = 0;
            int[][] tempData = new int[9][9];
            ArrayList<CellPosition> blankList = new ArrayList(70);
            for (int i = 0; i < 9; i++) {
                for (int j = 0; j < 9; j++) {
                    tempData[i][j] = puzzle[i][j];
                    if (tempData[i][j] == 0) {
                        blankCount++;
                        blankList.add(new CellPosition(i, j));
                    }
                }
            }

            if (isPuzzleValid(tempData) == false) {
                return false;
            }
            if (blankCount == 0) {
                return true;
            } else if (findNumberToPutInPositionN(tempData, 0, blankList)) {
                for (int i=0; i<9; i++){
                    System.arraycopy(tempData[i], 0, puzzle[i], 0, 9);
                }
                return true;
            }
            return false;
        }

        // if a number 1-9 can be put in position N, then store it and return true, otherwise return false
        protected boolean findNumberToPutInPositionN(int[][] data, int n, ArrayList<CellPosition> blankList) {
            if (n < blankList.size()) {
                CellPosition position = new CellPosition();
                position.positionX = blankList.get(n).positionX;
                position.positionY = blankList.get(n).positionY;
                for (int i = 1; i < 10; i++) {
                    data[position.positionX][position.positionY] = i;
                    if (validateValueAtCell(data, position.positionX, position.positionY)
                            && findNumberToPutInPositionN(data, n + 1, blankList)) {
                        return true;
                    }
                }
                data[position.positionX][position.positionY] = 0;
                return false;
            } else {
                return true;
            }
        }

        protected void equalChange(int[][] data) {
            Random rand = new Random();
            int num1 = 1 + rand.nextInt(9);
            int num2 = 1 + rand.nextInt(9);
            for (int i = 0; i < 9; i++) {
                for (int j = 0; j < 9; j++) {
                    if (data[i][j] == 1) {
                        data[i][j] = num1;
                    } else if (data[i][j] == num1) {
                        data[i][j] = 1;
                    }

                    if (data[i][j] == 2) {
                        data[i][j] = num2;
                    } else if (data[i][j] == num2) {
                        data[i][j] = 2;
                    }
                }
            }
            return;
        }

        protected void nextHole(int startX, int startY, int[] nextHole){

            switch (m_Level) {
                case 1:
                    nextHole[0] = ran.nextInt(9);
                    nextHole[1] = ran.nextInt(9);
                    break;
                case 2:
                    if (startX == 8 && startY == 7) {
                        nextHole[0] = 0;
                        nextHole[1] = 0;
                    } else if (startX == 8 && startY == 8) {
                        nextHole[0] = 0;
                        nextHole[1] = 1;
                    } else if ((startX % 2 == 0 && startY == 7) || (startX % 2 == 1) && startY == 0) {
                        nextHole[0] = startX + 1;
                        nextHole[1] = startY + 1;
                    } else if ((startX % 2 == 0 && startY == 8) || (startX % 2 == 1) && startY == 1) {
                        nextHole[0] = startX + 1;
                        nextHole[1] = startY - 1;
                    } else if (startX % 2 == 0) {
                        nextHole[0] = startX;
                        nextHole[1] = startY + 2;
                    } else if (startX % 2 == 1) {
                        nextHole[0] = startX;
                        nextHole[1] = startY - 2;
                    }
                    break;
                case 3:
                    if (startX == 8 && startY == 8) {
                        nextHole[1] = 0;
                    } else if (startX % 2 == 0 && startY < 8) {
                        nextHole[1] = startY + 1;
                    } else if ((startX % 2 == 0 && startY == 8) || (startX % 2 == 1 && startY == 0)) {
                        nextHole[1] = startY;
                    } else if (startX % 2 == 1 && startY > 0) {
                        nextHole[1] = startY - 1;
                    }

                    if (startX == 8 && startY == 8) {
                        nextHole[0] = 0;
                    } else if ((startX % 2 == 0 && startY == 8) || (startX % 2 == 1) && startY == 0) {
                        nextHole[0] = startX + 1;
                    } else {
                        nextHole[0] = startX;
                    }
                    break;
                case 4:
                    if (startY == 8) {
                        if (startX == 8) {
                            nextHole[0] = 0;
                        } else {
                            nextHole[0] = startX + 1;
                        }
                        nextHole[1] = 0;
                    } else {
                        nextHole[0] = startX;
                        nextHole[1] = startY + 1;
                    }
                default:
                    break;
            }

        }
    } // end of puzzle generator

    private SudokuData puzzleData;
    public PuzzleGenerator puzzleGenerator;
    public PuzzlePlayer puzzlePlayer;

    public PuzzleController(){
        puzzleData = new SudokuData();
        puzzleGenerator = new PuzzleGenerator();
        puzzlePlayer = new PuzzlePlayer();
    }
}









